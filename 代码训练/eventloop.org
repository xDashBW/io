* 旧
** DONE 添加事件
CLOSED: [2023-02-03 Fri 17:48]
  
- State "DONE"       from              [2023-02-03 Fri 17:48]
*** DONE [100%] 如果是修改事件的化，那么 epoll_ctl 的 event(uint32) 不仅包括添加的, 还包括原来的.
CLOSED: [2023-02-03 Fri 17:48]

- State "DONE"       from              [2023-02-03 Fri 17:48]

** DONE 删除事件
- State "DONE"       from              [2023-02-03 Fri 17:48]
CLOSED: [2023-02-03 Fri 17:48]
** DONE 重构代码质量
CLOSED: [2023-02-04 Sat 14:44]
- State "DONE"       from "TODO"       [2023-02-04 Sat 14:44]
*** DONE 模块调整, 防止循环引入
CLOSED: [2023-02-04 Sat 01:03]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 01:03]
:LOGBOOK:
CLOCK: [2023-02-04 Sat 00:58]--[2023-02-04 Sat 01:03] =>  0:05
CLOCK: [2023-02-04 Sat 00:21]--[2023-02-04 Sat 00:22] =>  0:01
:END:

[event-internel.h]
[epoll.h] [event.h]<!-- <!-- <-> --> -->[event-internel.h]
[event.c]

*** DONE 命令调整，尤其是各种 event 混乱不堪
CLOSED: [2023-02-04 Sat 00:57]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 00:57]
:LOGBOOK:
CLOCK: [2023-02-04 Sat 00:22]--[2023-02-04 Sat 00:57] =>  0:35
:END:
- [X] eventloop -> None
- [X] event -> watcher
- [X] 各种 event 的混乱问题
  - [X]  首先是作为 short 的 event

    抓住核心, 就是两个状态的切换, 同理也可以做为队列的命名 

    - [X] 等待 -> wait_event
    - [X] 唤醒 -> wake_event 

  - [X] 还有 epoll_event 的命令, 就叫做 epoll_event_nums[], 临时的就叫做 epoll_event

*** DONE 给用户提供的宏参数
- State "DONE"       from              [2023-02-04 Sat 01:08]
CLOSED: [2023-02-04 Sat 01:08]
*** DONE 重写 EPOLL 模块, 仔细思考这里使用哈希表的逻辑是否正确
CLOSED: [2023-02-04 Sat 11:06]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 11:06]
:LOGBOOK:
CLOCK: [2023-02-04 Sat 09:35]--[2023-02-04 Sat 11:06] =>  1:31
:END:
- [X] 考虑是否用动态数组, 而不是哈希表, 验证是否 fd 是递增沾满数组?
- [X] 重写用数组

* 全新版
** DONE EventLoop 模型重构
CLOSED: [2023-02-04 Sat 15:48]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 15:48]
:LOGBOOK:
CLOCK: [2023-02-04 Sat 14:45]--[2023-02-04 Sat 15:48] =>  1:03
:END:
- [X] 思考 libevent1.4 在 eventloop 保留一个 inserted 链表有什么用吗 ? 

- [X] 画出模型

  eventloop
  [
    callback :   watcher -> watcher -> watcher
    [fds]:   [watcher->watcher, ... ,  watcher->watcher]
  ]

- [X] 添加节点会怎么样?

  - 先根据 fd 找到 fds 的下表, 判断是否有 other 事件( 读/ 写)节点, 从而判断是否是 add 还是 mod

  - 如果是 add,

  - 如果是 mod.

  - 插入链表

  - 调用 epoll->add()

- [X] 删除节点
  
  - 通过遍历两遍看能否找出除了我之外的节点或者计算次数，就能判断是否本 watcher 是注册的 socke 唯一. 如果是 list_head 循环可以直接在一个 if() 里面判断

  - 如果修改, 确认另一个事件的注册事件就好了. 相当于把两个变成一个

  - 如果删除

  - 移除节点(watcher)

** DONE EPOLL 后端
CLOSED: [2023-02-04 Sat 19:39]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 19:39]
:LOGBOOK:
CLOCK: [2023-02-04 Sat 19:13]--[2023-02-04 Sat 19:39] =>  0:26
:END:

- [X] 如果注册的是 data 是 watcher* 有什么好处?

  找到 watcher, 直接送到唤醒队列, 不用通过 fd 找两个

  - [X] 那如果直接根据 fd 处理两个有啥坏处吗?  

    - [X] 遍历两个找一个速度慢
  
    - [X] 如果要同时处理 fd 的两个

      - [X] 怎么判断是否唤醒? 返回的是某个 fd, 通过 fd 找到两个, 可能有一个是未唤醒的. 通过 event 证明不靠谱, 假如是上一次的没有清理呢? 

      - [X] 怎么如果前面的加进去, 后面在唤醒是不是重复加进去

** DONE Event 用户接口
CLOSED: [2023-02-04 Sat 20:27]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 20:27]
- State "STARTED"    from "DONE"       [2023-02-04 Sat 20:13]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 20:11]
- State "TODO"       from "DONE"       [2023-02-04 Sat 20:00]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 19:56]
:LOGBOOK:
CLOCK: [2023-02-04 Sat 20:25]--[2023-02-04 Sat 20:27] =>  0:02
CLOCK: [2023-02-04 Sat 20:13]--[2023-02-04 Sat 20:25] =>  0:12
CLOCK: [2023-02-04 Sat 20:00]--[2023-02-04 Sat 20:11] =>  0:11
CLOCK: [2023-02-04 Sat 19:52]--[2023-02-04 Sat 19:56] =>  0:04
:END:
** DONE EventLoop Dispatch
CLOSED: [2023-02-04 Sat 20:45]
- State "DONE"       from "STARTED"    [2023-02-04 Sat 20:45]
:LOGBOOK:
CLOCK: [2023-02-04 Sat 20:27]--[2023-02-04 Sat 20:45] =>  0:18
:END:
** TODO 我感觉用 c 写不下去了, 还是用 C++ 重写
:LOGBOOK:
CLOCK: [2023-02-04 Sat 20:46]--[2023-02-04 Sat 22:54] =>  2:08
:END:
** TODO 转向 c++, 把 boost/intrude 看下，借助之前的经验, 看能不能创造奇迹
*** DONE 大纲
CLOSED: [2023-02-05 Sun 00:13]
- State "DONE"       from "STARTED"    [2023-02-05 Sun 00:13]
:LOGBOOK:
CLOCK: [2023-02-04 Sat 22:54]--[2023-02-05 Sun 00:13] =>  1:19
:END:
- [X] Detail
  - [X] list_node
- [X] List_hook
- [X] list.hpp
  - [X] 用户接口: list
  - [X] 内部实现: list_impl
*** STARTED 搞懂几个关键函数 [3/4]
:LOGBOOK:
CLOCK: [2023-02-05 Sun 01:48]--[2023-02-05 Sun 02:22] =>  0:34
CLOCK: [2023-02-05 Sun 00:24]--[2023-02-05 Sun 01:14] =>  0:50
:END:
- [X] 继承后, 然后扔入容器
    - [X] 官方例程
        - [X] 创建若干节点, 直接 new 在 std::vector<> 内部, 演示侵入式的用法, 原来如此.
    - [X] 插入的时候是? 插入右值, 因为用的是引用. 且不会拷贝.
- [X] 从迭代器取值
- [X] 删除 
- [ ] 画出大纲
*** TODO 调试
*** TODO 复写一个自己的.
*** TODO 然后研究为什么会有那些奇怪的模板代码, 带来什么好处
** TODO 基本的 echo
** TODO 添加 bufferevent