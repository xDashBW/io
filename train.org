# 不要忙着堆进度，要安排自己的强化训练
# 某数学家说：不做题，就不会不断地逼自己思考

* 日练

如果，有失败了，那么就失败了。一切按照进度进行。
例如，今天没有准时起床，那就没有把，记录原因，继续堆任务。如果 18:00 前没有吃饭，也不好吃了

** JUST [#C] 反思和布置任务
DEADLINE: <2022-12-14 Wed 23:59 +1d> SCHEDULED: <2022-12-14 Wed +1d>

:LOGBOOK:
CLOCK: [2022-12-11 Sun 23:50]--[2022-12-12 Mon 00:06] =>  0:16
CLOCK: [2022-12-10 Sat 23:26]--[2022-12-11 Sun 00:32] =>  1:06
CLOCK: [2022-12-10 Sat 22:40]--[2022-12-10 Sat 23:18] =>  0:38
CLOCK: [2022-12-09 Sat 23:10]--[2022-12-09 Sat 23:59] =>  0:49
:END:

:PROPERTIES:
:LAST_REPEAT: [2022-12-10 Sat 23:18]
:END:

- State "GOOD"       from "JUST"       [2022-12-14 Wed 00:04]
- State "FAIL"       from "JUST"       [2022-12-14 Wed 00:00] \\
  一天都看学习通去了
- State "GOOD"       from "JUST"       [2022-12-12 Mon 00:06]
- State "GOOD"       from "JUST"       [2022-12-10 Sat 23:18]
- State "GOOD"       from "JUST"       [2022-12-10 Sat 00:54]

- [-] 2022.12.10

    - [X] 行动复盘

        - [X] <<Python 源码剖析>> 看不下去.

          早上起来是想要看 <<python 源码剖析的>>, 结果看了一半, 发现看不下去. 我觉得是我时候还不够, 连最基本的 python 官网教材都没有看完, 这让我失去了点信心, 我想改变策略.

        - [X] 从 libevent 到 nginx 

          不看这本 <<python 源码剖析>>, 看啥呢? 吃早餐的时候翻微信读书. 或许是待会要写 xfevent, 所以抱着兴趣翻了 <<nginx 源码剖析>>, 并且 git 了 nginx. 

          一看, 震惊, 这 nginx 写的太好了吧!!! 比 libevent 好百倍不止啊, 我在 libevent 代码里疑惑的地方, 看了 nginx 就懂了.

          本来 xfevent 是模仿 libevent 的, 现在立马 '叛变' 到 nginx. 我很后悔为啥不早点看 nginx.

          PS: 韦易笑的网络库一些写法有点模仿 nginx

    - [X] 全天知识复习与总结

        - [X] 从 nginx 学习 c 的数据结构

            - [X] 思想: 不要做任何的假设, 和规范

              所以 c 语言是个人的浪漫, 因为可以写出高性能且优雅的代码

                - [X] 直接返回 malloc () 的地址供给用户做修改

                  c 要写出 std::vector<> 一样的扩容数组, 如果是 void** , 那只能存对象, 存 int 也要 malloc 一份 int.

                  那 nginx 的做法是直接返回 void* 的地址, 你要存 int, 还是 struct, 自己看着办.

                - [X] 用 void* 做参数, 不用编译器去做类型安全

            - [X] 数组: 直接返回 void* 的最后一个元素, 不够就从内存池扩容

            - [X] 链表: std::queue<T> 类似, 先检测一个节点(void*array) 是否够, 直接返回最后一个链表节点的 back(), 否则新建立一个链表节点

            - [X] 队列 : 果然 list_head 是最好用的, 就凭 nginx 用这个做队列, 就比 libevent 那个混乱的宏

        - [X] Nginx 如何封装 epoll (add,del 接口都有可能 '修改事件' , 而非 add_new / del_old)

          nginx 专注网络, 所以一个 event 背后一定有 socket, 这个 socket 一定有 rev,wev

          所以检测方法:

          #+begin_src c

            ngx_event_t ev;
            uint32 event;

            conn = ev->connection;

            if (event == NGX_READ) {
                other = conn->write_event;
                ...
            }

            if (other->active) {
                mod = EPOLL_CTL_MOD;
            } else {
                mod = EPOLL_CTL_ADD;
            }

          #+end_src
          
        - [X] event dispatch 模块怎么做

          和过去对 libevent 的 dispatch 模块理解差不多吧!!!

            - [X] 接 EPOLL 层

              不要马上 callback(), 而是加入到队列, 由上层 event_dispatch 模块处理

            - [X] 专门执行 poll 唤醒队列 的函数

            - [X] 专门 loop 的函数

               用来设置各种状态, 接入上层

    - [ ] 疑问

        - [ ] Dispatch 模块专门设个 poll 唤醒队列的函数, 有啥用吗?

        - [ ] Dispatch 模块专门设个 loop 函数, 要检测什么状态呢? 有什么用吗?

        - [ ] Nginx 的那个链表数据结构有什么用? 就是作为无限扩容的 buffer ??

- [X] 2022.12.11

    - [X] 复盘

        - [X] Linux System Api 半通水

            今天早上起床看了 <<nginx>>, 翻了很多章, 我觉得就内存分配器有点难度. Http 章节还没有打算开始学

            普通内存分配器以前研究过韦易笑大佬的, 所以能够理解. 但是同时进程间共享内存与共享内存的内存分配器就难倒了. 这暴露了自己对 linux System Api 的匮乏

        - [X] 献血

          献血之后头有点晕, 因为我的学习方法是需要把大腿的血液倒流, 我怕血液不够出了意外, 所以休息了几个小时.

          确实对身体有点影响, 下午想眯一会, 结果眯了下午 5 点多

        - [X] Python 基础很差

          Python 不同于 c/c++, 看了源码懂了原理就行了, Python 写出优雅是很重要的, 我以前没有打好基础, 所以泰迪的考试都过不了

        - [X] 数据挖掘情况紧急

          很多不会做, 明天又要上课了, 要快点去补了.

    - [X] 知识总结

      总结: 啥也没有学到的一天
      
        - [X] <<Python 工匠>> 的编码规范

        - [X] RPC 的历史由来与相关分支了解

    - [X] 疑问: 无

- [X] 2022.12.12

  什么都没有学, 看了一天的学习通

- [X] 2022.12.13

  看了一天的 <<python工匠>>, 你别说, 很多我以前不懂的东西豁然开朗, 看的很爽
  
------------------------------------
  

** JUST [#C] 俯卧撑 100 个 : 30 分钟
SCHEDULED: <2022-12-15 Thu +2d> DEADLINE: <2022-12-15 Thu 08:00 +2d>
- State "FAIL"       from "JUST"       [2022-12-14 Wed 00:01] \\
  我也不知道为什么?
- State "FAIL"       from "JUST"       [2022-12-11 Sun 14:09] \\
  献血, 今天不能剧烈运动
- State "GOOD"       from "JUST"       [2022-12-09 Fri 13:23]
- State "FAIL"       from "JUST"       [2022-12-07 Wed 16:08] \\
  遗精
---------


** JUST [#C] 深吨 100 个 : 30 分钟
SCHEDULED: <2022-12-16 Fri +2d> DEADLINE: <2022-12-16 Fri 08:00 +2d>
- State "FAIL"       from "JUST"       [2022-12-14 Wed 23:21] \\
  训练量太大了，现在的我根本没有时间空出一个小时来训练
:PROPERTIE:LAST_REPEAT: [2022-12-14 Wed 23:21]S:

:END:

- State "FAIL"       from "JUST"       [2022-12-14 Wed 00:00] \\
  放假一天, 研究学习通
- State "FAIL"       from "JUST"       [2022-12-10 Sat 22:31] \\
  起床晚了,  7 点钟也晚了
- State "FAIL"       from "JUST"       [2022-12-08 Thu 13:46] \\
  起床晚了

---------


** JUST [#C] 跑步 4 公里
SCHEDULED: <2022-12-15 Thu +1d> DEADLINE: <2022-12-15 Thu 18:00 +1d>
- State "GOOD"       from "JUST"       [2022-12-14 Wed 23:21]
:PROPERTIE:LAST_REPEAT: [2022-12-14 Wed 23:21]S:

:END:
- State "GOOD"       from "JUST"       [2022-12-14 Wed 00:02]
- State "FAIL"       from "JUST"       [2022-12-14 Wed 00:01] \\
  放假一天, 研究学习通
- State "FAIL"       from "JUST"       [2022-12-11 Sun 14:10] \\
  献血, 今天不能剧烈运动
- State "GOOD"       from "JUST"       [2022-12-10 Sat 19:21]
- State "FAIL"       from "JUST"       [2022-12-09 Fri 18:51] \\
  没有跑 4 公里, 才跑了几圈
  
  1. 没有提前准备
  2. 没有做好觉悟
- State "GOOD"       from "JUST"       [2022-12-08 Thu 20:44]
- State "FAIL"       from "JUST"       [2022-12-07 Wed 20:44] \\
  遗精
---------


** JUST [#C] 6 点钟起床
SCHEDULED: <2022-12-15 Thu +1d> DEADLINE: <2022-12-15 Thu 06:10 +1d>
- State "FAIL"       from "JUST"       [2022-12-14 Wed 09:12] \\
  太晚睡, 起不来
:PROPERTIE:LAST_REPEAT: [2022-12-14 Wed 09:12]S:

:END:
- State "GOOD"       from "JUST"       [2022-12-14 Wed 00:01]
- State "FAIL"       from "JUST"       [2022-12-14 Wed 00:00] \\
  放假一天, 研究学习通
- State "GOOD"       from "JUST"       [2022-12-11 Sun 07:12]
- State "GOOD"       from "JUST"       [2022-12-10 Sat 23:20]
- State "FAIL"       from "JUST"       [2022-12-10 Sat 07:16] \\
  虽然失败, 但是 7 点起来了, 所以还能接收
  起床了, 然后又睡下去了. 因为只调了一个闹钟, 下次调 3 个
- State "FAIL"       from "JUST"       [2022-12-09 Fri 09:07] \\
  失败, 因为没有把手机藏好，早上闹钟一响就无意识的手机关了.
- State "FAIL"       from "JUST"       [2022-12-08 Thu 13:45] \\
  昨晚反思，这是第三阶段前的最后通牒
- State "FAIL"       from "JUST"       [2022-12-07 Wed 10:23] \\
  遗精
---------


** JUST [#C] 6 点之前吃晚饭，最迟 6点半，否则不吃！！！
SCHEDULED: <2022-12-15 Thu +1d> DEADLINE: <2022-12-15 Thu 18:10 +1d>
- State "GOOD"       from "JUST"       [2022-12-14 Wed 23:21]
:PROPERTIE:LAST_REPEAT: [2022-12-14 Wed 23:21]S:

:END:

- State "FAIL"       from "JUST"       [2022-12-14 Wed 00:02] \\
  吃宵夜了. 因为太饿了.
  
  1. 喝了农茶
  2. 晚饭吃的太少了，才吃一包泡面
  
  记住这个教训, 以后不管怎么样, 晚饭一定要吃好, 吃饱, 不好怕肥. 晚饭过后, 想休息就休息吧, 不要喝茶

- State "FAIL"       from "JUST"       [2022-12-14 Wed 00:01] \\
  放假一天, 研究学习通
:PROPERTIE:LAST_REPEAT: [2022-12-14 Wed 00:01]S:

:END:

- State "GOOD"       from "JUST"       [2022-12-11 Sun 18:41]
- State "GOOD"       from "JUST"       [2022-12-10 Sat 19:21]

- State "GOOD"       from "JUST"       [2022-12-09 Fri 18:52]

- State "GOOD"       from "JUST"       [2022-12-07 Wed 16:09]

---------

** LOOP LEETCODE 
DEADLINE: <2023-01-04 Wed +1d> SCHEDULED: <2023-01-04 Wed +1d>
:PROPERTIES:
:LAST_REPEAT: [2023-01-04 Wed 23:10]
:END:
- State "DONE"       from "LOOP"       [2023-01-04 Wed 23:10]
:LOGBOOK:
CLOCK: [2023-01-06 Thu 01:00]--[2023-01-06 Fri 2:30] =>  1:30
CLOCK: [2023-01-05 Thu 21:27]--[2023-01-05 Fri 23:05] =>  1:38
CLOCK: [2023-01-05 Thu 19:53]--[2023-01-05 Thu 21:00] =>  1:07
CLOCK: [2023-01-05 Thu 18:35]--[2023-01-05 Thu 19:53] =>  1:18
CLOCK: [2023-01-05 Thu 13:25]--[2023-01-05 Thu 14:50] =>  1:25
CLOCK: [2023-01-05 Thu 12:54]--[2023-01-05 Thu 13:25] =>  0:31
CLOCK: [2023-01-05 Thu 09:27]--[2023-01-05 Thu 11:48] =>  2:21
CLOCK: [2023-01-05 Thu 02:12]--[2023-01-05 Thu 02:46] =>  0:34
CLOCK: [2023-01-05 Thu 01:15]--[2023-01-05 Thu 01:55] =>  0:40
CLOCK: [2023-01-04 Wed 23:11]--[2023-01-04 Wed 23:25] =>  0:14
CLOCK: [2023-01-04 Wed 21:49]--[2023-01-04 Wed 22:58] =>  1:09
CLOCK: [2023-01-04 Wed 21:20]--[2023-01-04 Wed 21:49] =>  0:29
CLOCK: [2023-01-04 Wed 20:50]--[2023-01-04 Wed 21:19] =>  0:29
CLOCK: [2023-01-04 Wed 19:42]--[2023-01-04 Wed 20:50] =>  1:08
CLOCK: [2023-01-04 Wed 00:17]--[2023-01-04 Wed 2:09] =>  1:52
CLOCK: [2023-01-03 Tue 22:52]--[2023-01-03 Tue 23:38] =>  0:46
CLOCK: [2023-01-03 Tue 20:23]--[2023-01-03 Tue 21:06] =>  0:43
CLOCK: [2023-01-03 Tue 19:56]--[2023-01-03 Tue 20:19] =>  0:23
CLOCK: [2023-01-03 Tue 19:13]--[2023-01-03 Tue 19:39] =>  0:26
:END:

* 月练 
** TASK [#C] 把知识迁移到 base.org 
DEADLINE: <2022-12-30 Sun +1m> SCHEDULED: <2022-12-29 Fri +1m>

--------


** LOOP [#C] 写一个网络库，导给 py 使用 [28%]
DEADLINE: <2022-12-14 Fri> SCHEDULED: <2022-12-01 Thu>

- [X] <2022-12-10 Sat 08:00> 

:LOGBOOK:
CLOCK: [2022-12-10 Sat 20:40]--[2022-12-10 Sat 21:37] =>  0:57
CLOCK: [2022-12-10 Sat 19:27]--[2022-12-10 Sat 20:11] =>  0:44
CLOCK: [2022-12-10 Sat 16:42]--[2022-12-10 Sat 17:36] =>  0:54
CLOCK: [2022-12-10 Sat 15:37]--[2022-12-10 Sat 16:20] =>  0:43
CLOCK: [2022-12-10 Sat 14:39]--[2022-12-10 Sat 15:36] =>  0:57
CLOCK: [2022-12-10 Sat 12:01]--[2022-12-10 Sat 12:31] =>  0:30
CLOCK: [2022-12-10 Sat 08:25]--[2022-12-10 Sat 11:48] =>  3:23
CLOCK: [2022-12-07 Wed 21:09]--[2022-12-07 Wed 22:21] =>  1:12
CLOCK: [2022-12-07 Wed 18:30]--[2022-12-07 Wed 20:00] =>  1:30
CLOCK: [2022-12-07 Wed 16:10]--[2022-12-07 Wed 17:00] =>  0:50
CLOCK: [2022-12-07 Wed 11:50]--[2022-12-07 Wed 13:12] =>  1:22
CLOCK: [2022-12-07 Wed 10:20]--[2022-12-07 Wed 11:36] =>  1:16
:END:

- [X] 方法论

  以前我都是看别人写，其实去揣测别人的写法效率是有点低的。

  应该了解核心，然后自己写这个核心，遇到不懂的问题，再去看。

- [-] 基础库

    - [ ] 数组(std::vector) : 

    - [ ] 链表 : 不使用 list_head 的情况: 明确是单向链表, 只需要遍历, 普通链表可以每个节点节约一个指针的内存.

    - [ ] string : 用于将 c 字符串流转化为 byte 

    - [X] queue

    - [ ] 定时轮

    - [ ] 最小堆

    - [ ] 散列表

- [ ] 模块设计 -> C 语言设计模式

    - [ ] 预测

        - [ ] 如何解耦不同模块

        - [ ] 底层模块怎么提供给上层服务

        - [ ] 上层服务扩充脚本语言接口

- [ ] 并发模型 -> 实现多核 cpu

    - [ ] 进程模型

- [-] 事件轮询 -> 实现异步

    - [X] 原理：单线程

        - [X] 底层是 io 复用接口 / 唤醒接口 的 LOOP 

        - [X] 网络事件

            - [X] 用户注册读事件和写事件

        - [X] 几个调度队列
      
          LOOP 就是调度队列的 Event 挪来挪去。

          注册的进入注册队列，然后 epoll 返回后，如果 epoll io 复用读，写唤醒，则放入唤醒队列，统一处理。

          （所以，reactor 也是线性处理的，而非并行处理，只是不会阻塞网络，如果要执行耗时任务，会阻塞其他 socket）

          然后执行玩，根据一次性还是多次，重新放入调度队列

            - [X] 注册队列

            - [X] 唤醒队列

        - [X] Buffer 缓存

          给每个 socket 一个 buffer，当数据到达时，网络库复杂 read，防止上层应用阻塞，对于用户来说，使得’就绪态‘变成’完成态‘
      
    - [-] 代码组织

        - [X] 模块通信 flag
            - [X] event_dispatch_queue: wait/actvite

        - [-] 事件
            - [-] 接口
                - [X] event_init ()
                - [X] event_add()
                - [ ] event_del()
                    - [ ] FIXME
                        - [ ] 如果事件处于激活队列中，可以直接删除吗？
            - [X] 桥梁功能

              用户注册 -> event -> epoll -> 反馈给用户，Event 如何充当这个桥梁的作用？

                - [X]  唤醒时反馈给用户必要的信息 -> 回调函数接口设置

                  先不要考虑用户从 buffer 拿数据，就考虑唤醒用户

                - [X] 用户注册  ：一个 socket 可以注册读，写两个 event 

                  假设你是用户，我要给某个 socket 注册唤醒读事件，或写事件。

                  那么需要设置 Event，并且设置属性

                    - [X] socket fd 
                    - [X] callback：(int fd, short ev, void *args);
                    - [X] short ，你想要监控的事件，通过 内置宏提供给你设置。

                    一个事件定好了，没有改变的必要吧

        - [-] event_dispatch 

            - [-] 接口

                - [X] Post 

                    - [X] event_dispatch_queue_add
                    - [X] event_dispatch_queue_del

                - [X] event_dispatch_init

                - [-] event_dispatch_loop()

                    - [-] 只是把唤醒队列执行 callback 吗 ?

                      好像还真是, 把它放入唤醒队列后, 除了打印个 log 记录时间外, 啥也没有做???

                        - [-] 所以集中到唤醒队列统一处理, 而不是直接处理的好处有啥呢?

                            - [X] 可以控制, 把长任务放到后面, 避免阻塞短任务

                            - [ ] ??? 

                    - [X] 事件分发模块, 还有其他 '对外接口' 吗?
                      
                      上层接口:  os/unix/ngx_*_process, 该模块提供了 socket,thread 等上层的模块

                    - [X] 代码调用过过程

                        - [X] os/unix/ngx_single_process

                            - [X] 上层监听 flag,  是否该线程退出, 以及各种状态的变化

                            - [X] while 

                                - [X] event/ngx_process_event_and_timer()

                                    - [X] event/module/epoll/process() : 把 epoll_wait 的返回结果放入队列中

                                    - [X] Log 延时, 唤醒到执行的延时

                                    - [X] event/ngx_event_post/ngx_port_queue() : 处理队列的内容
                                
            - [X] 队列（事件）管理和统一 dispatch （调度，分发）
              
        - [-] io 复用后端 epoll / select / poll / kqueue 
            - [-] 接口
                - [X] epoll_new()
                - [X] epoll_add()
                - [X] epoll_del()
                - [ ] epoll_dispatch()
                                
            - [X] 封装 epoll_ctl(EPOLL_CTL_ALL)

              检测其余同一个 socket 的其他 event 是否存在，以设置 epoll_ctl 不同参数
          
                - [X] 该 socket 新 event， 则 socketfd 添加进红黑树（监控该socket）
                - [X] 修改，例如该 socket 从读变成写或者增加写事件，那直接修改就好了，删除后在加入是画蛇添足
                - [X] 从红黑树删除这个 socket = 不再监控该 socket

        - [ ] 事件的生命周期

            - [ ] 如果该 event 主动 free（），则是否调用 event_del

                - [ ] 如果该 event 本来就没有加入调度队列？

                - [ ] 

--------------------------------------


* 超人计划
** 第一阶段：摸清其思路
*** TASK [#C] Http server （支持 get/post/cgi），用浏览器访问，里面有个 cgi 留言板


*** TASK [#C] 实现一个简易的 redis, 或者给 redis 添加 10 条命令，或者把存储引擎换成 unqlite


*** TASK [#C] 给 apache 实现一个 module, 可以支持 lua 写服务 


*** TASK [#C] 给 nginx 添加 python 模块，可以用 python 写服务


*** TASK [#C] 用 c/c++/go 写一个代理翻墙软件，跑在海外租的 vps 上


*** TASK [#C] 实现简单的 tcp RPC 框架，并且在这个基础上做一个简单聊天


*** TASK [#C] 阅读 Linux 代码，应用层实现一个 Linux 的定时器
