#+title: 知识

* 散
** TASK [#C] 测试 asyncio 的性能和 libevent 进行对比
:LOGBOOK:
CLOCK: [2022-12-14 Wed 01:10]--[2022-12-14 Wed 01:14] =>  0:04
:END:
https://zhuanlan.zhihu.com/p/27258289
--------


** LOOP [#C] 计算机术语读法和听力
DEADLINE: <2022-12-12 Mon> SCHEDULED: <2022-12-09 Fri>


--------------------------------------------


** DONE [#C] proactor 和 reactor
DEADLINE: <2022-12-06 Tue> SCHEDULED: <2022-12-06 Tue>
:LOGBOOK:
CLOCK: [2022-12-06 Tue 23:08]--[2022-12-06 Tue 23:26] =>  0:18
CLOCK: [2022-12-06 Tue 20:55]--[2022-12-06 Tue 23:07] =>  2:12
:END:
- [X] reactor 和 proactor 的区别 

  就绪态与完成态

  不是因为 reactor 有 Buffer 就是 proactor，即使 reactor 有了 buffer 依旧是 ‘就绪态’，而 proactor 是完成态
  
- [X] 设计对比 / 为啥 reactor 更优雅 / 为啥 proactor 造成代码割裂？

    - [X] 多做多错

      多做一步不一定是好的，reactor 虽然是封装半成品 epoll，但是是最佳的设计。而 proactor 反倒是过度设计了。

    - [X] 割裂的 socket 数据

        - [X] reactor 的队列模型

          对于本来就有序的 socket 数据来说，就绪后网络库将其存放到 buffer（队列） 里，等程序员根据需求取数据。就是最优雅的做法

        - [X] proactor 的一个 callback 一个 buffer 

          本来有序的 socket 数据，散落在不同的 callback 中

    - [X] 对代码的影响：主动变成被动

      reactor 主动从 queue 取数据是主动，有助于整理代码

      而 proactor 的代码逻辑依赖与被动 callback，逻辑割裂
---------------


* 理论知识多看书
** LOOP [#C] <<操作系统导论>>
DEADLINE: <2022-12-12 Mon> SCHEDULED: <2022-12-12 Mon>
:LOGBOOK:
CLOCK: [2022-12-16 Fri 20:38]--[2022-12-16 Fri 20:38] =>  0:00
:END:

--------


** 计算机网络


** 计算机体系结构
*** DONE 指令系统简介，（诞生，与其他模块的关系等）
DEADLINE: <2022-10-05 Wed 09:55> SCHEDULED: <2022-10-05 Wed 08:50>
- 处理器架构，指令集，具体CPU型号 的 关系
  https://www.zhihu.com/question/23474438
  https://www.cnblogs.com/leinuo2016/p/16214796.html
  https://www.zhihu.com/question/349437202


*** DONE 指令系统组成
hen


*** DONE 二进制与数字逻辑电路
DEADLINE: <2022-10-04 Tue 08:30> SCHEDULED: <2022-10-04 Tue 08:00>
- 二进制表示
  - 原码与补码与定点数
  - 浮点数
    - 符号
    - 阶码
    - 尾数
- 数字逻辑电路
  - 组合逻辑
    没有存储单元，输入什么，就输出什么。
    - 应用
      - 门：与，或，非，与非，或与，异或
      - 加法器，选择器
  - 时序逻辑
    具有存储单元，不再是组合逻辑一样的输入输出，而是利用存储功能，达到开关的目的。

    - 时钟信号与高低电位与 C 控制器
      电信号控制
    - RS 锁
      上下两个 *与非门* 组成的蝴蝶结，基础组件
    - D 锁存器
      在 RS 锁存器的基础上，添加 （1） 两个与非门  （2） C 控制器 控制 D 输入
      - C = 0 ： 保持（保持的意思是不论 D 输入怎么变化，输出都保持原来的状态）
      - C = 1  ： 直通

      通过 C 控制器（时钟信号）控制 D 输入，使得 RS 能够像蓄水池一样，达到一个 *存储* 的假象，从而能够作为 *开关*
    - D 触发器
      两个 D 锁存器组成
      - C=0
    第一个锁存器直通，第二个保持
    - C=1
    第一个保持，第二个直通
    - C 从 0 变成 1
    D 的值被锁起来了
  - CMOS 电路
    讲点具体的，不管是组合逻辑电路还是信号逻辑电路，都是 CMOS 电路（电工知识吧？可能比较安全省电）。



*** DONE 简单运算器设计
DEADLINE: <2022-10-04 Tue 10:00> SCHEDULED: <2022-10-04 Tue 08:40>
- 基础背诵
  CPU 内负责的组件叫做算术逻辑单元（ALU）
  - 算术运算
  - 逻辑运算
  - 比较运算
  - 移位运算
  - 乘，除，开方
- 定点补码加法器
  - 基础之：一位全加器

  ...
  加法进位是加法器的核心，根据进位的处理方式不同，进行分类
  - 类别1 ：行波进位加法器
  - 类别2 ：先行进位加法器


*** DONE 总线设计
DEADLINE: <2022-10-04 Tue 12:00> SCHEDULED: <2022-10-04 Tue 10:43>
- 总线定义
  不仅用于传输信号，还是软件同硬件架构的桥梁
- 总线架构层级
  - 机械层：接口外形，尺寸
  - 电气层：信号描述，电源电压，电平标准
  - 协议层：信号时序，握手协议，命令格式，出错处理
  - 架构层：软件架构和硬件模块
- 划分：根据那个信号
  - 串行
  - 并行
- 划分：根据物理位置进行划分
  - 片上总线：芯片内模块（例如处理器芯片上：处理器核，内存控制器等多个模块）之间的总线
  - 内存总线：处理器与主存储器之间的主线
  - 系统总线：处理器与桥卡之间，或多个处理器相连成并行处理器
  - 设备总线：处理器与 IO 设备之间


*** DONE 片上总线
DEADLINE: <2022-10-04 Tue 16:00> SCHEDULED: <2022-10-04 Tue 14:10>
片上总线是 芯片内部模块， （处理器上芯片：处理器核，内存控制器，缓存）等之间的总线
- AXI 协议
  1. 主从单向流通
  2. 控制（版本）信息与数据分离
- AXI 架构
  - 单架构
    读写
  - 互连架构
    每个主设备都可以访问从设备
- 事务
- 其他总线
  ASB，ASP 等，是典型的共用单通道
  但是片上总线要求的是并行性，所以具有分离通道的 AXI 脱颖而出。
- 通过AXI总线互连架构连接 高性能CPU的组件
  主设备：  CPU 核   CPU 核   CPU 核
  (9)       (9)     (9)
  AXI 总线
  （9）
  最后缓存
  （9）    （9）    （9）
  AXI 总线
  （9）     （9）    （9）
  内存控制器   内存控制器   内存控制器
-----------  ---------------


** LOOP [#C] <<python 数据结构与算法分析>>  : 我想拼一把, 我想看看现在到晚上, 我能做到什么程度, 如果明天之前还没有搞定, 那就把它放入 task 吧.
DEADLINE: <2022-12-15 Thu> SCHEDULED: <2022-12-15 Thu>
:LOGBOOK:
CLOCK: [2022-12-15 Thu 14:08]--[2022-12-15 Thu 15:26] =>  1:18
:END:
- [X] 目标: 知识体系与课后所有题目
- [X] [[~/code/git/xDashBW-create/base/]]
--------
  - [-] 栈
      - [X] 使用内置列表封装
      - [ ] 应用
          - [ ] 匹配括号
          - [ ] 十进制转化为二进制
          - [ ] 前中后序
          - [ ] 对协程也算有点了解了 ? 好了，一份工作而已.

--------


** DONE [#C] Python 工匠 [62%]
DEADLINE: <2022-12-11 Sun> SCHEDULED: <2022-12-11 Sun>

:LOGBOOK:
CLOCK: [2022-12-15 Thu 11:10]--[2022-12-15 Thu 13:37] =>  2:27
CLOCK: [2022-12-15 Thu 09:10]--[2022-12-15 Thu 10:37] =>  1:27
CLOCK: [2022-12-14 Wed 00:45]--[2022-12-14 Wed 01:10] =>  0:25
CLOCK: [2022-12-14 Wed 00:32]--[2022-12-14 Wed 00:45] =>  0:13
CLOCK: [2022-12-13 Tue 22:04]--[2022-12-13 Tue 22:50] =>  0:46
CLOCK: [2022-12-13 Tue 21:07]--[2022-12-13 Tue 21:42] =>  0:35
CLOCK: [2022-12-13 Tue 20:09]--[2022-12-13 Tue 20:41] =>  0:32
CLOCK: [2022-12-13 Tue 18:53]--[2022-12-13 Tue 20:09] =>  1:16
CLOCK: [2022-12-13 Tue 14:00]--[2022-12-13 Tue 17:00] =>  3:00
CLOCK: [2022-12-13 Tue 10:00]--[2022-12-13 Tue 12:30] =>  2:30
CLOCK: [2022-12-13 Tue 08:20]--[2022-12-13 Tue 09:30] =>  1:10
CLOCK: [2022-12-11 Sun 18:41]--[2022-12-11 Sun 20:12] =>  1:31
CLOCK: [2022-12-11 Sun 15:36]--[2022-12-11 Sun 15:49] =>  0:13
:END:

- [X] 异常, with 上下文管理器(释放资源)

    - [X] Python 安全机制

      如何使用 python, 看 python 怎么处理错误就知道了. 那就是让其出错, 不做任何保证，反正代码写错了, 有异常 catch 住

        - [X] 错误: 与其写各种 if 判断用户传入的类型是否符合

            #+begin_src python
              def safe_value(value):
                  if isinstance(value, int):
                      return value + 1
                  elif isinstance(value, str) and value.isdigit():
                      return int(value) + 1 
            #+end_src

        - [X] 正确: 不如错误直接抛异常

            #+begin_src python
              def safe_value(value):
                  try:
                      return value + 1
                  except Except as e:
                      ...
            #+end_src
      
    - [X] Python 的异常技巧
    
        - [X] 使用 with 上下文管理器回收资源

            __enter__() 当作 with ... as 的值

            __exit__() 退出 with 语句时回收资源

        - [X] raise

        - [X] __exit__() 可以重新抛出异常

- [X] 函数与鸭子类型

  类型系统在 python 里一点也不重要, 重要的是接口, 只要符合接口, 就符合标准

- [X] 整数, 浮点数, 字符串, 字节串

- [X] 容器与可迭代类型

  容器都是可迭代类型, 所以可以用 for ... in 的方式取值

  也可以从其他可迭代类型构建
  
    - [X] 创建方法

      当集合 / 字典为空时, 他们使用符号的构建方式一样, 所以此时集合不能使用 {} 构建, 要使用 set()
      
        - [X] 列表 : 列表推导式 ; []        ; 内置函数 list()   ; 
        - [X] 元祖 :           ; () / 逗号 ; 内置函数 tuple()  ; 函数返回值 / 函数参数: *
        - [X] 集合 : 集合推导式 ; {}        ; 内置函数 set()    ;
        - [X] 字典 : 字典推导式 ; {}        ; 内置函数 dict()   ;

    - [X] 浅拷贝和深拷贝

      这里的概念和 cpp 不一样, 不管是浅还是深, 都相当于把 *内存管理的值* 拷贝一份, 而不是引用

        - [X] 引用

          Python 的变量非常特殊, 在 java 中引用赋值, 起码还是对引用的对象操作, 在 python 中, 则是直接给变量搬家了.

        - [X] 浅
            - [X] copy()
            - [X] 切片

        - [X] 深
            - [X] deepcopy()

- [X] 生成器, 迭代器, 可迭代器类型

  可迭代类型是实现了 __iter__(), 证明可以迭代的对象

  迭代器是实现了 __iter__(), __next__() 可以循环调用的

  生成器是有 yield 关键字的

  而他们都可以配合 for...in

- [ ] 装饰器

- [ ] 面对对象

- [ ] 面向对象高级 - 设计模式

--------


** LOOP [#C] <<Python 源码剖析>>

:LOGBOOK:
CLOCK: [2022-12-10 Sat 07:18]--[2022-12-10 Sat 07:46] =>  0:28
:END:
<2022-12-10 Sat 6:20>
-----------------------------------------------------


** LOOP [#C] <<nginx 源码剖析>>
DEADLINE: <2022-12-13 Thu> SCHEDULED: <2022-12-10 Sat>
:LOGBOOK:
CLOCK: [2022-12-11 Sun 07:12]--[2022-12-11 Sun 07:55] =>  0:43
:END:

- [X] <2022-12-11 Sat 6:20> 

----------------------


* 实战项目
** DONE [#C] Pygame 贪吃蛇
SCHEDULED: <2022-12-07 Wed> DEADLINE: <2022-12-09 Fri>
:LOGBOOK:
CLOCK: [2022-12-09 Fri 21:46]--[2022-12-09 Fri 22:07] =>  0:21
CLOCK: [2022-12-09 Fri 13:29]--[2022-12-09 Fri 14:42] =>  1:13
CLOCK: [2022-12-09 Fri 09:08]--[2022-12-09 Fri 10:59] =>  1:51
CLOCK: [2022-12-08 Thu 11:42]--[2022-12-08 Thu 13:00] =>  1:18
:END:

- [X] 第一次写业务逻辑的大致流程（框架）
    - [X] 开启框架和 fps 
    - [X] 全局常量：字体，颜色
    - [X] 全局变量，贪吃蛇结构，地图
    - [X] 开启 While （） 的事件循环
    - [X] 在 while 里面开启 for 键盘监听
    - [X] 更新对应的数据结构（蛇的长度和位置，草莓的位置，方向等）
    - [X] 更新的数据结构在屏幕绘制
        - [X] 填充背景    : fill(color)
        - [X] 在矩阵地图绘画数据结构 : pygame.draw.rect()
        - [X] 屏幕大换血
    - [X] 检测退出条件(撞墙)和退出
        - [X] 当碰到墙壁
        - [X] 当碰到自己
    - [X] 设置 fps 刷新率
    - [X] 写退出函数

- Bug [2/2]

    - [X] 无法监听用户的方向按键

      [[~/code/old/write/贪吃蛇/main2.py]]

        - [X] 原因

          其实监听到了, 错误原因出在 '贪吃蛇数据结构', 没有考虑用户不输入按键时, 贪吃蛇头沿着原来的方向延伸

        - [X] 修正
              
            设立一个方向变量, 方向改变则, 如果不变, 就是原方向

    - [X] 坐标和蛇列表的转化

      [[~/code/old/write/贪吃蛇/2022.12-08.py]]

        - [X] 蛇的列表对于二维坐标的转化, 有误, 所以无法拼出正确的蛇身
        - [X] 二维坐标一维坐标是对应列, 之前搞反了

--------------------------------------------


** Android 客户端与聊天软件
*** DONE 安卓 im 软件的问题定义与需求分析

DEADLINE: <2022-09-19 Mon 11:31> SCHEDULED: <2022-09-19 Mon 09:31>

- 背景

  网络工程《软件工程》课程实训项目。

- 功能描述

    - Android UI 界面与逻辑

      Android 客户端除了编写用户界面与逻辑，对接服务器端

    - 登录服务器与图片服务器

        1. 提供用户注册，登录，注销功能。
        2. 除了用户编写信息外，图片服务器还允许用户上传头像等 PNG 图片。
        3. 心跳功能，维持用户在线状态与检查用户是否在线，是否踢掉用户。

    - 文件 FTP 服务器

      为用户提供传输文件服务

    - 聊天服务器

        1. 1 V 1 添加好友，显示好友是否在线，聊天功能。
        2. 群聊功能

- 硬件环境，软件环境
    - 服务端生产环境
      操作系统：Linux x64 Debian10
      数据库： Sqlite
      编程语言：使用 C 编写底层的网络服务，上层使用 Python 编写业务逻辑。目前考虑单机，以后可能扩展为分布式。
    - 客户端环境
      目前只支持 Android 端，服务器允许使用命令行 telnet 进行网络调试。


*** DONE 使用 Python 写服务器端的网络框架了解:Gevent
DEADLINE: <2022-09-19 Mon 21:30> SCHEDULED: <2022-09-19 Mon 22:30>
- 如何使用
  - 虽然 Gevent 依赖与 Greenlet。但是对于用户来说，并没有直接使用 GreenLet，而是直接使用 Gevent 的封装。
  - 只用设置一个启动的回调，然后就直接在这个启动函数写逻辑代码，连接开关和读写。不用像 Muduo 一样设置读，写，连接回调分割业务逻辑。
- 依赖与相关模块
  : use greenlet to provide a high-level synchronous API on top of libev event loop.
  : greenlet 负责提供协程调度，而 Libev 提供异步回调接口。
  - greenlet
    - QUESTION
      + 是否是内置模块？
    不是，Greenlet 依旧是一个第三方模块，通过 C 扩展实现协程。
    + Python 的协程通过第三方库实现，难道没有一套内置的线程 / 协程实现吗？
    ？？
    -
  - Libev
- 源码阅读


*** DONE Python 网络编程入门之 GIL 锁与协程的发展
DEADLINE: <2022-09-20 Tue 10:40> SCHEDULED: <2022-09-20 Tue 07:40>
- Python 多线程
  - GIL 锁

    - 为什么引入？
      为了实现线程安全的引用计数，Python 的 GC 实现是类似 C++ shared_ptr 一样的引用计数，所以为了保证全局更新所有变量的引用计数，所以必须引入一个全局锁。
      : 也就是说 GIL 锁的本质是 Python 的 GC 引起的。

    - 缺点
      - 全局引起的 *无法利用多核*
    即时有多个 CPU 依旧无法利用多核优势

    - 粗粒度锁，依旧无法做到 *线程安全*
    虽然，GIL 锁限制了只有一个 CPU / (执行单元) 访问变量。
    但是这个锁的粒度并非像以前的 C++ mutex 一样，由程序员进行控制。
    换句话说，很多 Python 的操作并不是原子的，依旧不是线程安全的。

- 协程
  - 生态的发展
    因为多线程的羸弱，Python 把注意力集中在协程上。事实上，在 Golang 协程问世前，Gevent 就早已经声名鹤起。

    - 带来的优势
      1. 已经积累了大量的协程框架和协程服务。
      2. 文件与数据库
      异步框架都只是涉及到网络部分，而 Python 经过多年的发展很多地方均已协程化。

  - 底层协程化
    ？？

  - 模块
    - 标准库
    - 老牌的协程 Gevent


*** DONE Python 如何利用多核？
DEADLINE: <2022-09-20 Tue 11:50> SCHEDULED: <2022-09-20 Tue 10:50>
- 多线程 （ERROR）
  python 多线程因为 GIL 锁的原因无法利用多核。

- 协程   （ERROR）
  协程只是把 selector 等异步事件同步化。但是依旧没有解决多核的问题。

- 多进程 + 协程/(异步reactor)（RIGHT）
  其实算是曲线救国，因为
  - 那些书本中拿协程取代多线程的例子是错的。
    因为在服务器中，使用多线程的目的在于利用多核。
    把多线程改成协程，并不能利用多核优势。
    如果这样做只是为了不阻塞应用，那说明这个例子本身就是错误的示范，正确的例子是单线程异步模型 + 多线程 Loop。

    所以，这个例子顶多说明了 *协程* 可以简化 *单线程的异步模型* ，让 Python 可以不阻塞应用。（虽然本来也可以异步模型，只是麻烦）

    : 说明 Python 可以不用线程而用协程做到不阻塞（虽然这样用线程是错误的）。但是忽视了线程的重要作用：利用多核。
  - 比较好的书籍笔记节选
    不过也不需要那么悲观，Python提供了其他方式可以绕过GIL的局限，比如使用多进程multiprocessing模块或者采用C语言扩展的方式，以及通过ctypes和C动态库来充分利用物理内核的计算能力。


*** DONE Python 深入 From《流畅 Python》：理解 Python 的数据模型
DEADLINE: <2022-09-20 Tue 16:30> SCHEDULED: <2022-09-20 Tue 14:30>
- Python 数据模型非常牛



*** DONE Python 协程入门
DEADLINE: <2022-09-20 Tue 20:30> SCHEDULED: <2022-09-20 Tue 17:30>


*** DONE Python 多线程与多进程
DEADLINE: <2022-09-21 Wed 10:00> SCHEDULED: <2022-09-21 Wed 08:00>


*** DONE POSTGRESQL
: from 七周七數據庫
- 命令行
  1. 創建數據庫：createdb xxoo
  2. 進入數據庫: psql xxoo (使用 psql)
- SQL 語句
  - 屬性類型
    - 字符串
  - varchar(9) ： 長度可以達到 9 個字節
  - char(2)    ： 正好要存儲 2 個字節
  - text    ： 任意長度
  - 修飾符
    - Primary Key：主鍵，具有唯一性約束，可以設置 *定義的兩個屬性* 爲主鍵
  + 如果不指定主鍵會怎麼樣？
    - UNIQUE ：讓除了 Primary Key 外的其他列（屬性） 具有唯一性
    - NOT NULL ： 不能爲空
    - CHECK （指定約束）   ： 指定約束
    - REFERENCE 表： 外鍵約束，該屬性能夠引用另一張表
  - CRUD
    - CREATE TABLE xxoo (name 類型 屬性，);
    - SELECT * from xxoo;
    - INSERT INTO xxoo VALUE （'','',''# 直接輸入值就行了）
    - UPDATE xxoo SET xx=yy WHERE xx=yy


** TASK [#C] 用 python 重写野火 im 的服务器端
SCHEDULED: <2022-12-13 Tue> DEADLINE: <2022-12-20 Tue>


* 领域技能
** LOOP [#C] Linux 同步机制与 api (进程, 线程, 锁, 信号)
DEADLINE: <2022-12-12 Mon> SCHEDULED: <2022-12-12 Mon>
--------


** LOOP [#C] Nginx 内存管理
SCHEDULED: <2022-12-12 Mon> DEADLINE: <2022-12-12 Mon>

--------


** TASK [#C] KCP 
DEADLINE: <2022-12-20 Tue> SCHEDULED: <2022-12-14 Wed>

:LOGBOOK:

:END:
------------------------------------


** TASK [#C] pygame
---------------------


** TASK [#C] unity3d
:LOGBOOK:
CLOCK: [2022-12-09 Fri 01:20]--[2022-12-09 Fri 01:49] =>  0:29
:END:
- [ ] 安装没有搞定, 因为 deb 包，要 debtap. 可惜 deptap 的下载速度太慢了
----------------------


** WAIT [#C] RPC
SCHEDULED: <2022-12-16 Fri> DEADLINE: <2023-01-05 Thu>

:LOGBOOK:
CLOCK: [2022-12-11 Sun 23:20]--[2022-12-11 Sun 23:49] =>  0:29
CLOCK: [2022-12-11 Sun 22:18]--[2022-12-11 Sun 22:54] =>  0:36
:END:

- [ ] 入门: 大纲, 种类, 与历史发展

    - [ ] SOA

        - [ ] RPC 

        - [ ] REST

        - [ ] SOAP

    - [ ] SOA

        - [ ] 中间件

        - [ ] 微服务

    - [ ] RPC

    - [ ] 消息队列

- [ ] 

--------



** TASK [#C] pyqt
DEADLINE: <2022-12-20 Sun> SCHEDULED: <2022-12-11 Sun>


---------


** TASK [#C] android


--------


* 设计语言
** TASK [#C] C


** Python
*** DONE python 异步编程的发展史
DEADLINE: <2022-11-08 Tue 16:45> SCHEDULED: <2022-11-08 Tue 16:30>
:LOGBOOK:
CLOCK: [2022-11-08 Tue 16:31]--[2022-11-08 Tue 16:48] =>  0:17
:END:
- [X] 异步回调时代
  可以追溯到 python2
  - [X] swisted
  - [X] tongo
- [X] 协程时代
  : Python 很早就开始大规模使用协程
  - [X] Python 3.4
    - [X] yield 生成器模拟步进 next()
    - [X] Gevent : greenlet 和 libev 结合
      没有内置的同步原语，就是 monkey Patch 替换

  - [X] python 3.5：从标准网络库和原语发展
    - [X] asyncio
    - [X] async/await
      底层是 yield, 所以好好了解下 yield，非常有必要

  - [X] 全面协程化（除了网络）
    社区，借助 async/await 原语，与类似 asyncio 的数据库 io 复用结合，诞生了数据库连接的协程库，

    - [X] aiomysql

    - [X] aiohttp: 进一步封装 asyncio 作为 http 服务器


*** DONE CYthon 的底层原理
DEADLINE: <2022-11-23 Wed 16:00> SCHEDULED: <2022-11-23 Wed 14:00>
:LOGBOOK:
CLOCK: [2022-11-23 Wed 16:15]--[2022-11-23 Wed 17:36] =>  1:21
:END:
-----------------------------------------------------
- [X] 任务目标
  根据 socket 模块的 gethostname 的延伸，为啥标准库 lib/python/ 里面没有 def gethostname 的源代码，不得不想联想到和 c 的关系
-----------------------------------------------------
- [X] https://awesome-programming-books.github.io/python/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf
------------------------------------------------------
- [X] Cython gethostname() 解释工作的原理？
  背后有一个 c 函数，Python 解释器去调用 c 函数
- [X] 怎么看 cpython 的解释器源码 / 如何看待 gethostname 对应的 c 代码扩展？
- [X] 到底是特殊的 c 模块翻译成 py? 还是 py 所有语句都翻译成 c 模块
  都不是，而是底层虚拟机根据上层的解析后的 py 代码分词作出指令，而虚拟机是 c 写的，所以当然最后是 c 代码。这里的低效是上层 py 代码的低效，而 c 模块直接调用不需要虚拟机的翻译过程
- [ ] 怎么通过 c 代码扩展 python?

*** TASK [#C] Python 协程的一个很好的教程
https://peps.python.org/pep-0492/


*** python 官方文档
**** DONE 大纲
:LOGBOOK:
CLOCK: [2022-11-11 Fri 08:00]--[2022-11-12 Sat 18:31] => 34:31
:END:

因为我看文档比看任何垃圾博客，看任何书要高效，对程序员的锻炼更好，王勇大哥就是这样进步来的。
不是要过面试吗？看什么书都不如看官方文档，所以最高优先级给到官方文档
-----------------------------------------------------
- [X] 任务目标
  全方位的学习 Python
-----------------------------------------------------
- [X] https://docs.python.org/zh-cn/3/contents.html
------------------------------------------------------


**** 主教材 
***** DONE [#C] 数字, 字符串
DEADLINE: <2022-12-14 Wed> SCHEDULED: <2022-12-14 Wed>
:LOGBOOK:
CLOCK: [2022-12-14 Wed 16:50]--[2022-12-14 Wed 18:55] =>  2:05
:END:

***** DONE [#C] 流程控制
DEADLINE: <2022-12-14 Wed 20:30> SCHEDULED: <2022-12-14 Wed>
:LOGBOOK:
CLOCK: [2022-12-14 Wed 20:46]--[2022-12-14 Wed 21:51] =>  1:05
:END:

***** DONE [#C] python 数据结构
SCHEDULED: <2022-12-10 Sat> DEADLINE: <2022-12-10 Sat>


***** DONE [#C] Python 错误与异常
DEADLINE: <2022-12-14 Wed 22:30> SCHEDULED: <2022-12-14 Wed>
:LOGBOOK:
CLOCK: [2022-12-14 Wed 21:54]--[2022-12-14 Wed 22:09] =>  0:15
:END:


***** DONE [#C] Python 标准库大纲
DEADLINE: <2022-12-14 Wed 23:00> SCHEDULED: <2022-12-14 Wed>
:LOGBOOK:
CLOCK: [2022-12-14 Wed 22:20]--[2022-12-14 Wed 23:40] =>  1:20
:END:


**** Python 标准库模块
***** DONE [#C] python socket
SCHEDULED: <2022-12-08 Thu> DEADLINE: <2022-12-10 Sat>
:LOGBOOK:
CLOCK: [2022-12-09 Fri 14:53]--[2022-12-09 Fri 15:29] =>  0:36
CLOCK: [2022-12-08 Thu 13:58]--[2022-12-08 Thu 15:10] =>  1:12
:END:
https://docs.python.org/zh-cn/3/library/socket.html
[[~/code/pirture/python教材/网络编程/]]

- [X] 预测

    - [X] socket 模块功能

      socket 模块，你觉得需要什么？

        - [X] socket 从概念上，应该和 io 事件复用解耦。

            一个异步框架，底层是 io 复用为核心的 reactor 反应堆。

            socket 可以模块可以注册进入这个异步框架，得到一个异步网络框架。

            同理，其余模块，例如数据库也可以把 event 注册进入 reactor 得到异步数据库。

        - [X] 功能，就是 unix 的那些同步 read，write，listen 功能

            - [X] 宏

              设置 socket 的底层网络类型，例如 tcp， udp

            - [X] 网络监听设置
                - [X] listen
                - [X] bind 地址，ipv4，ipv6

            - [X] 普通文件描述符号，收发数据

    - [X] socket 代码组织方式
        - [X] socket 常量宏： socket.INET_ADDR
        - [X] socket 异常  ： socket.error
        - [X] 功能函数：inet_hton (和 muduo 一样优雅)
        - [X] 关键类
            - [X] socket
            - [X] AddressFamily: 十分关键，参数里十分常见
                - [X] socket 类
                    - [X] __init__(AddressFamily)
                    - [X] family() -> AddressFamily
                - [X] getaddrinfo -> list[tuple(AddressFamily)]
      
- [X] 官方例子：

    - [X] 核心模型，只服务一个对象的 echo，示范最简单的 socket 模块的 bind,listen,accept

      [[~/code/pirture/python教材/网络编程/socket模块/server0.py]]

    - [X] 学习如何处理边界条件, 例如 getaddrinfo 处理 bind 多个地址, 以及异常处理

      [[~/code/pirture/python教材/网络编程/socket模块/server1.py]]
      

---------


***** TASK [#C] python asynio


**** 句法与核心语义 
***** LOOP [#C] Python 内置类型
DEADLINE: <2022-12-20 Tue> SCHEDULED: <2022-12-09 Fri>
:LOGBOOK:
CLOCK: [2022-12-16 Fri 20:38]--[2022-12-16 Fri 20:38] =>  0:00
:END:

- [X] 上下文管理类型

    Python 定义了一些上下文管理器来支持简易的线程同步、文件或其他对象的快速关闭，以及更方便地操作活动的十进制算术上下文


***** LOOP [#C] Python 数据模型
DEADLINE: <2022-12-20 Tue> SCHEDULED: <2022-12-09 Fri>
:LOGBOOK:
CLOCK: [2022-12-09 Fri 19:26]--[2022-12-09 Fri 19:57] =>  0:31
:END:

- [X] 特殊方法 
    - [X]  上下文管理有关的 with 两招
        - [X] __enter__() 
        - [X] __exit__()
---------------------


***** DONE [#C] Python 复合语句 [100%]
SCHEDULED: <2022-12-09 Fri> DEADLINE: <2022-12-10 Sat>
:LOGBOOK:
CLOCK: [2022-12-09 Fri 22:27]--[2022-12-09 Fri 23:00] =>  0:33
CLOCK: [2022-12-09 Fri 18:52]--[2022-12-09 Fri 20:00] =>  1:08
CLOCK: [2022-12-09 Fri 17:08]--[2022-12-09 Fri 17:19] =>  0:11
CLOCK: [2022-12-09 Fri 16:26]--[2022-12-09 Fri 16:50] =>  0:24
CLOCK: [2022-12-09 Fri 15:31]--[2022-12-09 Fri 16:26] =>  0:55
:END:

[[~/code/pirture/python教材/复合语句/except_as.py]]

- [X] 普通逻辑 if,for,while
- [X] 函数定义与类定义: 从 python 的角度来说, 这也是一种 "python 复合语句定义"
- [X] 异常 try 语句

- [X] With
    - [X] 使用上下文表达式求值得到上下文管理器   模块:  Python / 内置类型 / 上下文表达式
        - [X] 使用上下文管理器调用特殊方法      模块: Python / 数据模型 / 特殊方法  
            - [X] __enter__()
            - [X] __exit__()
  
- [X] 协程原语
    - [X] await 唤醒
    - [X] async 
        - [X] 函数细粒度: async
        - [X] for     : async for
            - [X] 模块
                - [X] Python / 数据模型 / 特殊方法
            - [X] __aiter__()
            - [X] __anext__()
        - [X] with    : async with
            - [X] 模块
                - [X] Python / 内置类型 / 上下文表达式
                - [X] Python / 数据模型 / 特殊方法
            - [X] __aenter__()
            - [X] __aexit__()

    是提供了协程原语, 用来保留寄存器, 跳出函数

    要能够服务应用生产, 还需要配合其他东西,
        - [X] 底层事件轮询 asyncio + 网络模块 socket =  Python 网络编程 2022 
        - [X] 底层事件轮询 aysncio + 数据库模块      =  Python 非阻塞数据库 2022

-------------------------------------------


* 工具篇

** DONE [#C] Latex
DEADLINE: <2022-12-08 Thu> SCHEDULED: <2022-12-08 Thu>
:LOGBOOK:
CLOCK: [2022-12-08 Thu 23:00]--[2022-12-08 Thu 23:56] =>  0:56
CLOCK: [2022-12-08 Fri 20:00]--[2022-12-08 Fri 20:40] =>  0:40
:END:

https://emacs-china.org/u/zhcosin/activity Emacs 社区很会搞 latex 的大牛, 多看他回答

- [X] Org-mode 和 latex-mode : 公式多就 latex-mode, 文字多就 org-mode 里面插入 latex 代码 

- [X] 几种可以 latex 编辑器

    - [X] GNU TexMacs 
      
      底层依旧是 latex, 可以像 wps 等富文本编辑器一样(专门用来编辑公式), 多了很多工具栏, 可以让你不需要直接编辑 latex 公式.

      所以，相比 emacs 等编辑器只能文本编辑 latex, texmacs 可以容易作出调整(不用重新编辑 latex 公式, 或者快捷键弄下就好了), 所以适合写草稿
      
        - 官方介绍
          aur/texmacs 2.1.2-1 (+4 0.10) 
          Free scientific text editor, inspired by TeX and GNU Emacs. Wysiwyg editor TeX-fonts and CAS-interface (Giac, GTybalt, Macaulay 2, Maxima, Octave, Pari, Qcl, R and Yacas) in one. 是不是和 emacs 一样? 先看看!!!

    - [X] 莫干编辑器
      
      GNU Texmacs 是一个数学排版工具, 但是维护者的野心不止于此, 所以出现了像 emacs 架构靠近的 mogan editor, 专门为科研人员设计.

    - [X] Emacs Latex (或其他 latex 宿主, Latex 以插件的形式集成进编辑器, 同时编辑器只能编辑 latex 源码, 最多 preview )
        - [X] auctex 插件
        - [X] cdlatex 插件

- [X] 学习思路
    - [X] 适用下 texmacs
    - [X] 使用下莫甘编辑器( 也就是一个排版工具, 和 latex 不是同一种)
    - [X] 把他们结合下 emacs : 先用内置的熟悉下, 你才能知道自己要的是什么

- [X] 我的选择:
    - [X] Latex 编辑器选择: 我还是用 emacs+latex 的做法, 因为我草稿不多, 更偏向于整理知识.
    - [X] Emacs 插件选择 : 先用内置的, 才知道自己想要什么

-----------      --------------------------------------------


** Git
*** TASK [#C] git 如何回退版本
https://zhuanlan.zhihu.com/p/137856034
--------------------------------------


*** DONE [#C] 如何不同的模式使用通一套快捷键
-----------------------------


** Emacs

Emacs 思想, 一句话, 要快.
那些配置文件, 甚至是知识库, 随便改, 乱改就乱改, 无所谓, 但是就是要快

*** DONE 如何调整变化

- [X] 终极任务

  反而好改，直接改截止时间

- [X] 衍生任务

  A 类任务不会作为衍生任务，因为 A 类任务是打卡任务

  先取消一部分任务，然后在对剩余任务调整

  目的是啥？把时间空出来

    - [X] 取消

        - [X] WAIT 可以考虑取消，减少工作量

        - [X] LOOP 可以考虑完结

    - [X] 调整

        - [X] 把关键任务提前

            - [X] WAIT：最好，还没有开始，调整截止时间和起始时间

            - [X] LOOP ：调整截止时间，

        - [X] 把不关键的任务，但是取消了可惜的任务，往后面延期（这个任务一定是 LOOP）

          那么就简单了，直接把截止时间延迟到 终极任务 DEADLINE + 原来截止时间


*** TASK [#C] 怎么高效使用 emacs 的快捷键，减少无效的键盘敲击

- [ ] 针对每行的 copy 和 yank

  Emacs 的 copy 真的效率很低，两个问题

  - [ ] 无法从中间开始操作，每次都要定位到行首或行尾

  - [ ] 没有（找到）专用的针对整行的 copy 方法，每次都要 mask 一次

- [ ] 像 vim 一样选定多行操作，例如多行复制，拷贝
-----------------------------------------------------


*** DONE [#C] Mode, Hook 设置快捷键和设置变量，Local 快捷键
:LOGBOOK:
CLOCK: [2022-12-01 Thu 00:15]--[2022-12-01 Thu 00:55] =>  0:40
CLOCK: [2022-11-30 Wed 19:15]--[2022-11-30 Wed 21:16] =>  2:01
:END:
- [X] hook
    - [X] 快捷键
    - [X] 变量

- [X] 主 mode 和 submode

- [X] 全局快捷键和某个 mode 的 local 快捷键

----------------------------------------------------------------


*** TASK [#C] 写一个 eaf-code-search
:LOGBOOK:
CLOCK: [2022-11-30 Wed 18:48]--[2022-11-30 Wed 19:01] =>  0:13
:END:
---------------------------------------------


*** TASK [#C] fork sort-tab 开发分组功能，分组内优先级计数和分组外优先级计数
-----------------------------------------------------
